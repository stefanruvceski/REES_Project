///////////////////////////////////////////////////////////
//  Weather.cs
//  Implementation of the Class Weather
//  Generated by Enterprise Architect
//  Created on:      16-maj-2018 10.31.48
//  Original author: Stefan
///////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using WeatherCommon.Classes;
using Microsoft.WindowsAzure.Storage.Table;

namespace WeatherWorkerRoleData.Classes
{


    public class WindGeneratorBase : TableEntity
    {
        private string weather;
        private string windMill;
        private int windMillCnt;
        private string aggregate;
        private double aggregatePower;
        private double power;
        private int aggregateONCnt;
        private double totalAggregateCost;

        public WindGeneratorBase()
        {

        }

        public WindGeneratorBase(string weather, string windMill, int windMillCnt, string aggregate)
        {
            if(weather == null || windMill == null || aggregate == null)
            {
                throw new ArgumentNullException("Arguments can't be null.");
            }

            if(windMillCnt <= 0)
            {
                throw new ArgumentException("Farm must have more than 0 windmills.");
            }

            PartitionKey = "WindGenerator";
            RowKey = weather;

            this.weather = weather;
            this.windMill = windMill;
            this.windMillCnt = windMillCnt;
            this.aggregatePower = Repositories.aggregateRepository.GetOneAggregate(aggregate).Power * windMillCnt;
            this.aggregate = aggregate;
            
            WindMillBase w = Repositories.windMillRepository.GetOneWindMill(windMill);

            if(w.MinPower == 2000 || w.MinPower == 2600 || w.MinPower == 3700 || w.MinPower == 8800 || w.MinPower == 17000 || w.MinPower == 40000)
            {
                w.MinPower *= windMillCnt;
            }                

            Repositories.windMillRepository.AddOrReplaceWindMill(w);

        }

        public string Weather { get => weather; set => weather = value; }
        public string WindMill { get => windMill; set => windMill = value; }
        public int WindMillCnt { get => windMillCnt; set => windMillCnt = value; }
        public string Aggregate { get => aggregate; set => aggregate = value; }
        public double Power { get => power; set => power = value; }
        public double AggregatePower { get => aggregatePower; set => aggregatePower = value; }
        public int AggregateONCnt { get => aggregateONCnt; set => aggregateONCnt = value; }
        public double TotalAggregateCost { get => totalAggregateCost; set => totalAggregateCost = value; }

        public double CalculatePower()
        {
            WeatherBase weatherBase = Repositories.weatherRepository.GetLastWeather(Weather);

            if (weatherBase == null)
                weatherBase = Repositories.weatherRepository.GetOneWeather(weather);
            WindMillBase windMillBase = Repositories.windMillRepository.GetOneWindMill(WindMill);
            
            double power = 0;

            if (weatherBase.WindSpeed >= windMillBase.MaxSpeed && windMillBase.WorkingTime < windMillBase.MaxSpeedTime)
            {
                power = 0.5 * windMillBase.Coefficient * weatherBase.AirDensity * CalculateSurfaceArea(windMillBase) * Math.Pow(weatherBase.WindSpeed, 3);
                windMillBase.WorkingTime++;
            }
            else if ( windMillBase.WorkingTime >= windMillBase.MaxSpeedTime)
            {
                power = 0;
                windMillBase.WorkingTime++;
            }
            else
            {
                power = 0.5 * windMillBase.Coefficient * weatherBase.AirDensity * CalculateSurfaceArea(windMillBase) * Math.Pow(weatherBase.WindSpeed, 3);
                windMillBase.WorkingTime = 0;
            }

            if (windMillBase.WorkingTime == windMillBase.MaxSpeedTime+ (windMillBase.MaxSpeedTime / 2)) // cooling period
            {
                windMillBase.WorkingTime = 0;
            }
            Repositories.windMillRepository.AddOrReplaceWindMill(windMillBase);
        
            return power * windMillCnt;
        }

        public double CalculateSurfaceArea(WindMillBase windMillBase)
        {
            if(windMillBase == null)
            {
                throw new ArgumentNullException("Argument can't be null.");
            }

            if(windMillBase.TurbineDiameter <= 0)
            {
                throw new ArgumentException("Turbine diameter must be greater than 0.");
            }

            return Math.Pow((windMillBase.TurbineDiameter / 2), 2) * Math.PI;
        }

        public double CalculateTotalAggregateCost(double dieselPrice)
        {
            AggregateBase aggregateBase = Repositories.aggregateRepository.GetOneAggregate(aggregate);

            return aggregateBase.CostPerHour * AggregateONCnt * WindMillCnt;
        }

    }//end Weather

}//end namespace WeatherWorkerRoleData